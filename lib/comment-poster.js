import { execSync } from 'child_process';

export class CommentPoster {
  constructor(provider) {
    this.provider = provider;
    this.postedComments = [];
  }
  
  /**
   * Post a reply to a specific comment
   */
  async replyToComment(prId, comment, replyText, options = {}) {
    try {
      // Add reaction emoji if specified
      if (options.reaction) {
        await this.addReaction(prId, comment.id, options.reaction);
      }
      
      // Post the reply
      const result = await this.provider.postComment(prId, replyText, {
        inReplyTo: comment.id,
        isInline: comment.type === 'review'
      });
      
      this.postedComments.push({
        originalComment: comment.id,
        reply: result,
        timestamp: new Date().toISOString()
      });
      
      return result;
    } catch (error) {
      console.error(`Failed to reply to comment ${comment.id}: ${error.message}`);
      throw error;
    }
  }
  
  /**
   * Post a general comment on the PR
   */
  async postGeneralComment(prId, body) {
    try {
      const result = await this.provider.postComment(prId, body);
      
      this.postedComments.push({
        type: 'general',
        reply: result,
        timestamp: new Date().toISOString()
      });
      
      return result;
    } catch (error) {
      console.error(`Failed to post general comment: ${error.message}`);
      throw error;
    }
  }
  
  /**
   * Add a reaction to a comment
   */
  async addReaction(prId, commentId, reaction) {
    // Map decision to emoji
    const reactionMap = {
      'AUTO_FIX': '‚úÖ',
      'REJECT': '‚ùå',
      'DISCUSS': 'üí¨',
      'DEFER': 'üìù',
      'ESCALATE': '‚ö†Ô∏è'
    };
    
    const emoji = reactionMap[reaction] || reaction;
    
    try {
      // GitHub reactions API
      execSync(
        `gh api -X POST repos/${this.provider.repo}/issues/comments/${commentId}/reactions -f content='${this.getGitHubReaction(emoji)}'`,
        { stdio: 'pipe' }
      );
    } catch (error) {
      // Reaction might not be supported, continue anyway
      console.warn(`Could not add reaction ${emoji}: ${error.message}`);
    }
  }
  
  /**
   * Convert emoji to GitHub reaction type
   */
  getGitHubReaction(emoji) {
    const map = {
      '‚úÖ': '+1',
      '‚ùå': '-1',
      'üí¨': 'eyes',
      'üìù': 'heart',
      '‚ö†Ô∏è': 'confused',
      'üöÄ': 'rocket',
      'üëÄ': 'eyes'
    };
    return map[emoji] || 'eyes';
  }
  
  /**
   * Post a summary comment with all actions taken
   */
  async postSummary(prId, decisions, changes) {
    const summary = this.buildSummary(decisions, changes);
    return await this.postGeneralComment(prId, summary);
  }
  
  buildSummary(decisions, changes) {
    const stats = {
      total: decisions.length,
      autoFixed: decisions.filter(d => d.action === 'AUTO_FIX').length,
      rejected: decisions.filter(d => d.action === 'REJECT').length,
      discussed: decisions.filter(d => d.action === 'DISCUSS').length,
      deferred: decisions.filter(d => d.action === 'DEFER').length
    };
    
    let summary = `## ü§ñ PR Review Assistant Summary\n\n`;
    summary += `Processed **${stats.total}** review comments:\n\n`;
    
    if (stats.autoFixed > 0) {
      summary += `- ‚úÖ **Auto-fixed**: ${stats.autoFixed} issues\n`;
    }
    if (stats.rejected > 0) {
      summary += `- ‚ùå **Rejected**: ${stats.rejected} (valid project patterns)\n`;
    }
    if (stats.discussed > 0) {
      summary += `- üí¨ **Needs Discussion**: ${stats.discussed}\n`;
    }
    if (stats.deferred > 0) {
      summary += `- üìù **Backlogged**: ${stats.deferred}\n`;
    }
    
    if (changes && changes.length > 0) {
      summary += `\n### Files Modified\n`;
      changes.forEach(change => {
        summary += `- \`${change.path}\`: ${change.description}\n`;
      });
    }
    
    if (stats.discussed > 0) {
      summary += `\n### ‚ö†Ô∏è Requires Your Attention\n`;
      summary += `@stroupaloop - ${stats.discussed} comments need your input. `;
      summary += `Check the üí¨ reactions above.\n`;
    }
    
    summary += `\n---\n`;
    summary += `*Generated by [pr-review-assistant](https://github.com/stroupaloop/pr-review-assistant)*`;
    
    return summary;
  }
  
  /**
   * Update a previous comment
   */
  async updateComment(commentId, newBody) {
    try {
      execSync(
        `gh api -X PATCH repos/${this.provider.repo}/issues/comments/${commentId} -f body="${newBody}"`,
        { stdio: 'pipe' }
      );
      return { success: true };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
}

export function createCommentPoster(provider) {
  return new CommentPoster(provider);
}